{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OGC","text":"<p>ogc - provisioning, that's it.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Welcome to the getting started guide! This should be a quick introduction to get up and running with OGC. More information on customizing and extending OGC can be found in the user documentation.</p>"},{"location":"#install","title":"Install","text":"<p>We use and recommend the use of Poetry:</p> <pre><code>$ pip install poetry\n$ poetry install\n</code></pre>  <p>Caution</p> <p>If using poetry make sure to prefix running of <code>ogc</code> with the following:</p> <pre><code>$ poetry run ogc\n</code></pre> <p>Optionally, load up the virtualenv beforehand:</p> <pre><code>$ poetry shell\n</code></pre>  <p>Or install from pypi:</p> <pre><code>$ pip install ogc\n</code></pre>"},{"location":"#provider-setup","title":"Provider Setup","text":"<p>OGC currently supports AWS and GCP out of the box (more added soon). In order for OGC to connect and deploy to these clouds a few environment variables are needed. </p> <p>Create a <code>.env</code> file in the top level directory where <code>ogc</code> is to be run:</p> <pre><code>AWS_ACCESS_KEY_ID=\"\"\nAWS_SECRET_ACCESS_KEY=\"\"\nAWS_REGION=\"us-east-2\"\n\nGOOGLE_APPLICATION_CREDENTIALS=\"svc.json\"\nGOOGLE_APPLICATION_SERVICE_ACCOUNT=\"..@...iam.gserviceaccount.com\"\nGOOGLE_PROJECT=\"example-project\"\nGOOGLE_DATACENTER=\"us-central1-a\"\n</code></pre>  <p>Note</p> <p>More information can be found in our Providers documentation.</p>"},{"location":"#define-provisioning","title":"Define Provisioning","text":"<p>Once setup is complete, a provision layout is needed.</p> <p>Create a file <code>ubuntu.py</code>:</p> <pre><code>from ogc.deployer import Deployer\nfrom ogc.log import get_logger\nfrom ogc.models import Layout\nfrom ogc.provision import choose_provisioner\n\nlog = get_logger(\"ogc\")\n\nlayout = Layout(\n    instance_size=\"e2-standard-4\",\n    name=\"ubuntu-ogc\",\n    provider=\"google\",\n    remote_path=\"/home/ubuntu/ogc\",\n    runs_on=\"ubuntu-2004-lts\",\n    scale=5,\n    scripts=\"fixtures/ex_deploy_ubuntu\",\n    username=\"ubuntu\",\n    ssh_private_key=\"~/.ssh/id_rsa_libcloud\",\n    ssh_public_key=\"~/.ssh/id_rsa_libcloud.pub\",\n    ports=[\"22:22\", \"80:80\", \"443:443\", \"5601:5601\"],\n    tags=[],\n    labels=dict(\n        division=\"engineering\", org=\"obs\", team=\"observability\", project=\"perf\"\n    ),\n)\n\n# Alternatively\n# from ogc.provisioner import GCEProvisioner\n# provisioner = GCEProvisioner(layout=layout)\n\nprovisioner = choose_provisioner(layout=layout)\ndeploy = Deployer.from_provisioner(provisioner=provisioner)\ndef up(**kwargs):\n    deploy.up()\n\ndef run(**kwargs):\n    # pass in a directory/filepath -o path=fixtures/ubuntu\n    if kwargs.get(\"path\", None):\n        deploy.exec_scripts(scripts=kwargs[\"path\"])\n    # pass in a cmd with -o cmd='ls -l /'\n    elif kwargs.get(\"cmd\", None):\n        deploy.exec(kwargs[\"cmd\"])\n    else:\n        deploy.exec_scripts()    \n\ndef down(**kwargs):\n    deploy.down()\n</code></pre> <p>This specification tells OGC to deploy 5 nodes running on Google's e2-standard-4 with Ubuntu OS.  The <code>scripts</code> section tells OGC where the template files/scripts are located that need to be uploaded to each node during the deployment phase.</p>"},{"location":"#provision-and-deploy","title":"Provision and Deploy","text":"<p>Once the specification is set, environment variables configured, execute a deployment in a new terminal:</p> <pre><code>$ ogc up ubuntu.py\n$ ogc run ubuntu.py -o cmd='sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade'\n$ ogc down ubuntu.py\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<p>Learn how to manage your deployments in our User Guide - Managing a deployment</p>"},{"location":"commands/ogc/","title":"CLI Reference","text":"<p>This page provides documentation for our command line tool.</p>"},{"location":"commands/ogc/#ogc","title":"ogc","text":"<p>Manage and Provision machines</p> <p>Usage:</p> <pre><code>ogc [OPTIONS] SPEC TASK\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--options</code>, <code>-o</code> text Pass in -o KEY=VALUE -o KEY=VALUE which is used in the provision spec None   <code>--verbose</code>, <code>-v</code> boolean Turn on debug <code>False</code>   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"developer-guide/managing-nodes/","title":"Managing Nodes Programatically","text":""},{"location":"developer-guide/managing-nodes/#requirements","title":"Requirements","text":"<p>Accessing the functionality of OGC programatically requires that both cloud credentials and database access are configured. The environment variables for working with AWS or Google should be defined in your environment either by setting it in the <code>.env</code> or in the abscence of a dotenv file they can be exported by your current running shell.</p> <p>Using the <code>.env</code> is easiest and is what we'll use for the remaining documentation, the following will configure access to both AWS and Google along with defining where our Postgres database resides:</p> <pre><code>AWS_ACCESS_KEY_ID=\"abbcc\"\nAWS_SECRET_ACCESS_KEY=\"sshitsasecret\"\nAWS_REGION=\"us-east-2\"\n\nGOOGLE_APPLICATION_CREDENTIALS=\"mycreds.json\"\nGOOGLE_APPLICATION_SERVICE_ACCOUNT=\"bob@whodunit.iam.gserviceaccount.com\"\nGOOGLE_PROJECT=\"my-awesome-project\"\nGOOGLE_DATACENTER=\"us-central1-a\"\n</code></pre>"},{"location":"developer-guide/managing-nodes/#nodes","title":"Nodes","text":"<p>Once the database is setup in your code, you are ready to begin creating and managing nodes. OGC provides both synchronous and asynchronous support depending on your needs.</p>"},{"location":"developer-guide/managing-nodes/#launch-node","title":"Launch Node","text":"<p>To launch a node an OGC specification is required with at least one layout defined, create a file called <code>ubuntu.py</code>.</p> <pre><code>from ogc.deployer import Deployer\nfrom ogc.log import get_logger\nfrom ogc.models import Layout\nfrom ogc.provision import choose_provisioner\n\nlayout = Layout(\n    instance_size=\"e2-standard-4\",\n    name=\"ubuntu-ogc\",\n    provider=\"google\",\n    remote_path=\"/home/ubuntu/ogc\",\n    runs_on=\"ubuntu-2004-lts\",\n    scale=15,\n    scripts=\"fixtures/ex_deploy_ubuntu\",\n    username=\"ubuntu\",\n    ssh_private_key=\"~/.ssh/id_rsa_libcloud\",\n    ssh_public_key=\"~/.ssh/id_rsa_libcloud.pub\",\n    ports=[\"22:22\", \"80:80\", \"443:443\", \"5601:5601\"],\n    tags=[],\n    labels=dict(\n        division=\"engineering\", org=\"obs\", team=\"observability\", project=\"perf\"\n    ),\n)\nprovisioner = choose_provisioner(layout=layout)\n\ndeploy = Deployer.from_provisioner(provisioner=provisioner)\ndeploy.up()\ndeploy.exec(cmd='ls -l /')\ndeploy.exec_scripts()\ndeploy.exec_scripts(scripts='my/arbitrary/path')\ndeploy.down()\n</code></pre> <p>To launch this node layout:</p> <pre><code>$ ogc ubuntu.py\n</code></pre>"},{"location":"developer-guide/api/deployer/","title":"API","text":"<p>Deployer</p> <p>The <code>Deployer</code> instance is responsible for bringing up nodes for a particular provisioner, whether it be AWS or Google. This also has the responsibility of uploading/downloading files to/from node(s) and facilities for executing commands or a set of scripts on the node(s).</p>"},{"location":"developer-guide/api/deployer/#ogc.deployer.Deployer.provisioner","title":"provisioner  <code>class-attribute</code>","text":"<pre><code>provisioner: BaseProvisioner\n</code></pre>"},{"location":"developer-guide/api/deployer/#ogc.deployer.Deployer.db","title":"db  <code>class-attribute</code>","text":"<pre><code>db: t.Any\n</code></pre>"},{"location":"developer-guide/api/deployer/#ogc.deployer.Deployer.force","title":"force  <code>class-attribute</code>","text":"<pre><code>force: bool = False\n</code></pre>"},{"location":"developer-guide/api/deployer/#ogc.deployer.Deployer.from_provisioner","title":"from_provisioner  <code>classmethod</code>","text":"<pre><code>from_provisioner(\n    provisioner: BaseProvisioner, force: bool = False\n) -&gt; Deployer\n</code></pre>  <p>Obtain deployer instance</p> <p>Parameters:</p>    Name Type Description Default     <code>provisioner</code>  <code>BaseProvisioner</code>  <p>AWSProvisioner | GCEProvisioner</p>  required    <code>force</code>  <code>bool</code>  <p>Force load</p>  <code>False</code>     <p>Returns:</p>    Type Description      <code>Deployer</code>  <p><code>Deployer</code>: A deployer instance</p>     Source code in <code>ogc/deployer.py</code> <pre><code>@classmethod\ndef from_provisioner(\n    cls, provisioner: BaseProvisioner, force: bool = False\n) -&gt; Deployer:\n    \"\"\"Obtain deployer instance\n\n    Args:\n        provisioner (BaseProvisioner): AWSProvisioner | GCEProvisioner\n        force (bool): Force load\n    Returns:\n        `Deployer`: A deployer instance\n    \"\"\"\n    return Deployer(provisioner=provisioner, force=force, db=db.Manager())\n</code></pre>"},{"location":"developer-guide/api/deployer/#ogc.deployer.Deployer.up","title":"up","text":"<pre><code>up() -&gt; bool\n</code></pre>  <p>Bring up machines</p>  Source code in <code>ogc/deployer.py</code> <pre><code>def up(self) -&gt; bool:\n    \"\"\"Bring up machines\"\"\"\n    self.provisioner.setup()\n    self._nodes = t.cast(list[models.Machine], self.provisioner.create())\n    return True\n</code></pre>"},{"location":"developer-guide/api/deployer/#ogc.deployer.Deployer.down","title":"down","text":"<pre><code>down() -&gt; bool\n</code></pre>  <p>Tear down machines</p>  Source code in <code>ogc/deployer.py</code> <pre><code>def down(self) -&gt; bool:\n    \"\"\"Tear down machines\"\"\"\n    if not self.exec(\"./teardown\").ok():\n        log.debug(\"Could not run teardown script\")\n    self.provisioner.destroy(nodes=self.db.nodes().values())\n    for node_name in self.db.nodes().keys():\n        self.db.remove(node_name)\n    self.db.commit()\n    return True\n</code></pre>"},{"location":"developer-guide/api/deployer/#ogc.deployer.Deployer.exec","title":"exec","text":"<pre><code>exec(cmd: str) -&gt; Result[bool, Exception]\n</code></pre>  <p>Execute commands on node(s)</p> <p>Parameters:</p>    Name Type Description Default     <code>cmd</code>  <code>str</code>  <p>Command to run on node</p>  required     <p>Returns:</p>    Type Description      <code>Result[bool, Exception]</code>  <p>Result[bool, Exception]: True if succesful, False otherwise.</p>     Source code in <code>ogc/deployer.py</code> <pre><code>def exec(self, cmd: str) -&gt; Result[bool, Exception]:\n    \"\"\"Execute commands on node(s)\n\n    Args:\n        cmd (str): Command to run on node\n\n    Returns:\n        Result[bool, Exception]: True if succesful, False otherwise.\n    \"\"\"\n\n    def _exec(node: bytes, cmd: str) -&gt; bool:\n        _node: models.Machine = db.pickle_to_model(node)\n        cmd_opts = [\n            \"-i\",\n            str(_node.layout.ssh_private_key),\n            f\"{_node.layout.username}@{_node.public_ip}\",\n        ]\n        cmd_opts.append(cmd)\n        return_status = None\n        try:\n            out = sh.ssh(cmd_opts, _env=os.environ.copy(), _err_to_out=True)  # type: ignore\n            return_status = dict(\n                exit_code=out.exit_code,\n                out=out.stdout.decode(),\n                error=out.stderr.decode(),\n            )\n        except sh.ErrorReturnCode as e:\n            return_status = dict(\n                exit_code=e.exit_code,  # type: ignore\n                out=e.stdout.decode(),\n                error=e.stderr.decode(),\n            )\n        if return_status:\n            log.debug(f\"exit_code: {return_status['exit_code']}\")\n            log.debug(f\"out: {return_status['out']}\")\n            log.debug(f\"error: {return_status['error']}\")\n\n    nodes = self.db.nodes().values()\n    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:\n        func = partial(_exec, cmd=cmd)\n        results = [\n            executor.submit(func, db.model_as_pickle(node)) for node in nodes\n        ]\n        wait(results, timeout=5)\n        return Ok(True)\n</code></pre>"},{"location":"developer-guide/api/deployer/#ogc.deployer.Deployer.exec_scripts","title":"exec_scripts","text":"<pre><code>exec_scripts(\n    scripts: str | None = None,\n    filters: t.Mapping[str, str] | None = None,\n) -&gt; Result[bool, str]\n</code></pre>  <p>Execute scripts</p> <p>Executing scripts/templates on a node.</p> <p>Parameters:</p>    Name Type Description Default     <code>scripts</code>  <code>str</code>  <p>The full path or directory where the scripts reside locally.            Supports single file and directory.</p>  <code>None</code>    <code>filters</code>  <code>Mapping[str, str]</code>  <p>Filters to pass into exec, currently <code>name</code> and <code>tag</code> are supported.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Result[bool, str]</code>  <p>Result[bool, str]: True if succesful, False otherwise.</p>     Source code in <code>ogc/deployer.py</code> <pre><code>def exec_scripts(\n    self, scripts: str | None = None, filters: t.Mapping[str, str] | None = None\n) -&gt; Result[bool, str]:\n    \"\"\"Execute scripts\n\n    Executing scripts/templates on a node.\n\n    Args:\n        scripts (str): The full path or directory where the scripts reside locally.\n                       Supports single file and directory.\n        filters (Mapping[str, str]): Filters to pass into exec, currently `name` and `tag` are supported.\n\n    Returns:\n        Result[bool, str]: True if succesful, False otherwise.\n    \"\"\"\n\n    def _exec_scripts(node: bytes, scripts: str | None = None) -&gt; bool:\n        _node: models.Machine = db.pickle_to_model(node)\n        if not scripts:\n            scripts = _node.layout.scripts\n        _scripts = Path(scripts)\n        if not _scripts.exists():\n            return False\n\n        if not _scripts.is_dir():\n            scripts_to_run = [_scripts.resolve()]\n        else:\n            # teardown file is a special file that gets executed before node\n            # destroy\n            scripts_to_run = [\n                fname for fname in _scripts.glob(\"**/*\") if fname.stem != \"teardown\"\n            ]\n            # scripts_to_run.reverse()\n\n        context = Ctx(env=os.environ.copy(), node=_node, db=self.db)\n        steps: list[Deployment] = [\n            ScriptDeployment(script=render(s, context), name=s.name)\n            for s in scripts_to_run\n            if s.is_file()\n        ]\n\n        # Add teardown script as just a filedeployment\n        teardown_script = _scripts / \"teardown\"\n        if teardown_script.exists():\n            with tempfile.NamedTemporaryFile(delete=False) as fp:\n                temp_contents = render(teardown_script, context)\n                fp.write(temp_contents.encode())\n                steps.append(FileDeployment(fp.name, \"teardown\"))\n                steps.append(ScriptDeployment(\"chmod +x teardown\"))\n\n        if steps:\n            msd = MultiStepDeployment(steps)\n            ssh_client = _node.ssh()\n            if ssh_client:\n                msd.run(_node.remote, ssh_client)\n            for step in msd.steps:\n                match step:\n                    case FileDeployment():\n                        log.debug(\n                            f\"(source) {step.source if hasattr(step, 'source') else ''} \"\n                            f\"(target) {step.target if hasattr(step, 'target') else ''} \"\n                        )\n                    case ScriptDeployment():\n                        log.debug(\n                            f\"(exit) {step.exit_status if hasattr(step, 'exit_status') else 0} \"\n                            f\"(out) {step.stdout if hasattr(step, 'stdout') else ''} \"\n                            f\"(stderr) {step.stderr if hasattr(step, 'stderr') else ''}\"\n                        )\n                    case _:\n                        log.debug(step)\n        return True\n\n    nodes = self.db.nodes().values()\n    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:\n        func = partial(_exec_scripts, scripts=scripts)\n        results = [\n            executor.submit(func, db.model_as_pickle(node)) for node in nodes\n        ]\n        wait(results, timeout=5)\n        return Ok(all([res.result() is True for res in results])) or Err(\n            \"Unable execute scripts\"\n        )\n</code></pre>"},{"location":"developer-guide/api/deployer/#ogc.deployer.Deployer.put","title":"put","text":"<pre><code>put(\n    src: str,\n    dst: str,\n    excludes: list[str],\n    includes: list[str] = [],\n) -&gt; None\n</code></pre>  <p>Upload file to remote node(s)</p> <p>Parameters:</p>    Name Type Description Default     <code>src</code>  <code>str</code>  <p>The full path or directory where the scripts reside locally.</p>  required    <code>dst</code>  <code>str</code>  <p>Remote destination</p>  required    <code>excludes</code>  <code>list[str]</code>  <p>List of file patterns to exclude</p>  required    <code>includes</code>  <code>list[str]</code>  <p>List of file patterns to include</p>  <code>[]</code>     <p>Returns:</p>    Name Type Description     <code>None</code>  <code>None</code>  <p>nop.</p>     Source code in <code>ogc/deployer.py</code> <pre><code>@retry(tries=3, delay=5, jitter=(5, 15), logger=None)\ndef put(\n    self, src: str, dst: str, excludes: list[str], includes: list[str] = []\n) -&gt; None:\n    \"\"\"Upload file to remote node(s)\n\n    Args:\n        src (str): The full path or directory where the scripts reside locally.\n        dst (str): Remote destination\n        excludes (list[str]): List of file patterns to exclude\n        includes (list[str]): List of file patterns to include\n\n    Returns:\n        None: nop.\n    \"\"\"\n\n    def _put(\n        node: bytes,\n        src: str,\n        dst: str,\n        excludes: list[str],\n        includes: list[str] = [],\n    ) -&gt; None:\n        _node: models.Machine = db.pickle_to_model(node)\n        cmd_opts = [\n            \"-avz\",\n            \"-e\",\n            (\n                f\"ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \"\n                f\"-i {_node.ssh_private_key.expanduser()}\"\n            ),\n            src,\n            f\"{_node.username}@{_node.public_ip}:{dst}\",\n        ]\n\n        if includes:\n            for include in includes:\n                cmd_opts.append(f\"--include={include}\")\n\n        if excludes:\n            for exclude in excludes:\n                cmd_opts.append(f\"--exclude={exclude}\")\n        try:\n            sh.rsync(cmd_opts)\n        except sh.ErrorReturnCode as e:\n            log.error(f\"Unable to rsync: (out) {e.stdout} (err) {e.stderr}\")\n            return None\n\n    nodes = self.db.nodes().values()\n    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:\n        func = partial(_put, src=src, dst=dst, excludes=excludes, includes=includes)\n        results = [\n            executor.submit(func, db.model_as_pickle(node)) for node in nodes\n        ]\n        wait(results, timeout=5)\n</code></pre>"},{"location":"developer-guide/api/deployer/#ogc.deployer.Deployer.get","title":"get","text":"<pre><code>get(dst: str, src: str) -&gt; None\n</code></pre>  <p>Download file to remote node(s)</p> <p>Parameters:</p>    Name Type Description Default     <code>dst</code>  <code>str</code>  <p>Remote destination</p>  required    <code>src</code>  <code>str</code>  <p>The full path or directory where download files locally.</p>  required     <p>Returns:</p>    Name Type Description     <code>None</code>  <code>None</code>  <p>nop.</p>     Source code in <code>ogc/deployer.py</code> <pre><code>@retry(tries=3, delay=5, jitter=(5, 15), logger=None)\ndef get(self, dst: str, src: str) -&gt; None:\n    \"\"\"Download file to remote node(s)\n\n    Args:\n        dst (str): Remote destination\n        src (str): The full path or directory where download files locally.\n\n    Returns:\n        None: nop.\n    \"\"\"\n\n    def _get(node: bytes, dst: str, src: str) -&gt; None:\n        _node: models.Machine = db.pickle_to_model(node)\n        cmd_opts = [\n            \"-avz\",\n            \"-e\",\n            (\n                f\"ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \"\n                f\"-i {_node.ssh_private_key.expanduser()}\"\n            ),\n            f\"{_node.username}@{_node.public_ip}:{dst}\",\n            src,\n        ]\n        try:\n            sh.rsync(cmd_opts)\n        except sh.ErrorReturnCode as e:\n            log.error(f\"Unable to rsync: (out) {e.stdout} (err) {e.stderr}\")\n            return None\n\n    nodes = self.db.nodes().values()\n    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:\n        func = partial(_get, dst=dst, src=src)\n        results = [\n            executor.submit(func, db.model_as_pickle(node)) for node in nodes\n        ]\n        wait(results, timeout=5)\n</code></pre>"},{"location":"developer-guide/api/models/layout/","title":"API","text":"<p>Layout model</p> <p>Synopsis:</p> <pre><code>from __future__ import annotations\n\nimport typing as t\n\nfrom ogc.deployer import Deployer\nfrom ogc.log import get_logger\nfrom ogc.models import Layout\nfrom ogc.provision import choose_provisioner\n\nlog = get_logger(\"ogc\")\n\nlayout = Layout(\n    instance_size=\"e2-standard-4\",\n    name=\"ubuntu-ogc\",\n    provider=\"google\",\n    remote_path=\"/home/ubuntu/ogc\",\n    runs_on=\"ubuntu-2004-lts\",\n    scale=15,\n    scripts=\"fixtures/ex_deploy_ubuntu\",\n    username=\"ubuntu\",\n    ssh_private_key=\"~/.ssh/id_rsa_libcloud\",\n    ssh_public_key=\"~/.ssh/id_rsa_libcloud.pub\",\n    ports=[\"22:22\", \"80:80\", \"443:443\", \"5601:5601\"],\n    tags=[],\n    labels=dict(\n        division=\"engineering\", org=\"obs\", team=\"observability\", project=\"perf\"\n    ),\n)\nlog.debug(layout)\n\nprovisioner = choose_provisioner(layout=layout)\nlog.debug(provisioner)\n\ndeploy = Deployer.from_provisioner(provisioner=provisioner)\nlog.debug(deploy)\n\n\ndef up(**kwargs: str) -&gt; None:\n    deploy.up()\n\n\ndef run(**kwargs: str) -&gt; None:\n    if kwargs.get(\"path\", None):\n        log.info(f\"Executing scripts path: {kwargs['path']}\")\n        deploy.exec_scripts(scripts=kwargs[\"path\"])\n    elif kwargs.get(\"cmd\", None):\n        log.info(f\"Executing command: {kwargs['cmd']}\")\n        deploy.exec(kwargs[\"cmd\"])\n    else:\n        log.info(f\"Executing scripts path: {layout.scripts}\")\n        deploy.exec_scripts()\n\n\ndef down(**kwargs: str) -&gt; None:\n    log.info(f\"Teardown {deploy} - {kwargs}\")\n    deploy.down()\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.instance_size","title":"instance_size  <code>class-attribute</code>","text":"<pre><code>instance_size: str\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.provider","title":"provider  <code>class-attribute</code>","text":"<pre><code>provider: str\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.remote_path","title":"remote_path  <code>class-attribute</code>","text":"<pre><code>remote_path: str\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.runs_on","title":"runs_on  <code>class-attribute</code>","text":"<pre><code>runs_on: str\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.scale","title":"scale  <code>class-attribute</code>","text":"<pre><code>scale: int\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.scripts","title":"scripts  <code>class-attribute</code>","text":"<pre><code>scripts: str\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.username","title":"username  <code>class-attribute</code>","text":"<pre><code>username: str\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.ssh_private_key","title":"ssh_private_key  <code>class-attribute</code>","text":"<pre><code>ssh_private_key: t.LiteralString | Path = field(\n    converter=Path\n)\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.ssh_public_key","title":"ssh_public_key  <code>class-attribute</code>","text":"<pre><code>ssh_public_key: t.LiteralString | Path = field(\n    converter=Path\n)\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.tags","title":"tags  <code>class-attribute</code>","text":"<pre><code>tags: list[str] | None = field(\n    converter=convert_tags_to_slug_tags\n)\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.labels","title":"labels  <code>class-attribute</code>","text":"<pre><code>labels: t.Mapping[str, str] | None = None\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.ports","title":"ports  <code>class-attribute</code>","text":"<pre><code>ports: list[str] | None = None\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.arch","title":"arch  <code>class-attribute</code>","text":"<pre><code>arch: str | None = 'amd64'\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.artifacts","title":"artifacts  <code>class-attribute</code>","text":"<pre><code>artifacts: str | None = None\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.exclude","title":"exclude  <code>class-attribute</code>","text":"<pre><code>exclude: list[str] | None = None\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.extra","title":"extra  <code>class-attribute</code>","text":"<pre><code>extra: t.Mapping[str, str] | None = None\n</code></pre>"},{"location":"developer-guide/api/models/layout/#ogc.models.layout.Layout.include","title":"include  <code>class-attribute</code>","text":"<pre><code>include: list[str] | None = None\n</code></pre>"},{"location":"developer-guide/api/models/machine/","title":"API","text":""},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.remote","title":"remote  <code>class-attribute</code>","text":"<pre><code>remote: NodeType\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.layout","title":"layout  <code>class-attribute</code>","text":"<pre><code>layout: Layout\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.id","title":"id  <code>class-attribute</code>","text":"<pre><code>id: str = field(init=False, factory=get_new_uuid)\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.username","title":"username  <code>class-attribute</code>","text":"<pre><code>username: str | None = field(init=False)\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.ssh_private_key","title":"ssh_private_key  <code>class-attribute</code>","text":"<pre><code>ssh_private_key: Path = field(init=False)\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.ssh_public_key","title":"ssh_public_key  <code>class-attribute</code>","text":"<pre><code>ssh_public_key: Path = field(init=False)\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.instance_name","title":"instance_name  <code>class-attribute</code>","text":"<pre><code>instance_name: str | None = field(init=False)\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.instance_id","title":"instance_id  <code>class-attribute</code>","text":"<pre><code>instance_id: str | None = field(init=False)\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.instance_state","title":"instance_state  <code>class-attribute</code>","text":"<pre><code>instance_state: str | None = field(init=False)\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.public_ip","title":"public_ip  <code>class-attribute</code>","text":"<pre><code>public_ip: str | None = field(init=False)\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.private_ip","title":"private_ip  <code>class-attribute</code>","text":"<pre><code>private_ip: str | None = field(init=False)\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.created","title":"created  <code>class-attribute</code>","text":"<pre><code>created: datetime.datetime = field(\n    init=False, default=datetime.datetime.utcnow()\n)\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.extra","title":"extra  <code>class-attribute</code>","text":"<pre><code>extra: t.Mapping | None = None\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.tainted","title":"tainted  <code>class-attribute</code>","text":"<pre><code>tainted: bool = False\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.ssh","title":"ssh","text":"<pre><code>ssh() -&gt; ParamikoSSHClient | None\n</code></pre>  <p>Provides an SSH Client for use with provisioning</p>  Source code in <code>ogc/models/machine.py</code> <pre><code>@retry(tries=5, delay=5, jitter=(1, 5), logger=None)\ndef ssh(self) -&gt; ParamikoSSHClient | None:\n    \"\"\"Provides an SSH Client for use with provisioning\"\"\"\n    if self.public_ip and self.username:\n        _client = ParamikoSSHClient(\n            self.public_ip,\n            username=self.username,\n            key=str(self.ssh_private_key.expanduser()),\n            timeout=300,\n            use_compression=True,\n        )\n        _client.connect()\n        return _client\n    return None\n</code></pre>"},{"location":"developer-guide/api/models/machine/#ogc.models.machine.Machine.from_layout","title":"from_layout  <code>classmethod</code>","text":"<pre><code>from_layout(layout: Layout, node: NodeType) -&gt; Machine\n</code></pre>  <p>Grabs the objects for deployment/provision</p>  Source code in <code>ogc/models/machine.py</code> <pre><code>@classmethod\ndef from_layout(cls, layout: Layout, node: NodeType) -&gt; Machine:\n    \"\"\"Grabs the objects for deployment/provision\"\"\"\n    return Machine(\n        layout=layout,\n        remote=node,\n    )\n</code></pre>"},{"location":"developer-guide/api/models/utils/","title":"API","text":"<p>init</p>"},{"location":"developer-guide/api/models/utils/#ogc.models.utils.get_new_uuid","title":"get_new_uuid","text":"<pre><code>get_new_uuid() -&gt; str\n</code></pre>   Source code in <code>ogc/models/utils.py</code> <pre><code>def get_new_uuid() -&gt; str:\n    return str(uuid.uuid1())\n</code></pre>"},{"location":"developer-guide/api/models/utils/#ogc.models.utils.serialize","title":"serialize","text":"<pre><code>serialize(\n    inst: str,\n    field: str,\n    value: str | datetime.datetime | Path,\n) -&gt; str\n</code></pre>  <p>Serializes value into its proper type</p>  Source code in <code>ogc/models/utils.py</code> <pre><code>def serialize(inst: str, field: str, value: str | datetime.datetime | Path) -&gt; str:\n    \"\"\"Serializes value into its proper type\"\"\"\n    if isinstance(value, datetime.datetime):\n        return value.isoformat()\n    if isinstance(value, Path):\n        return str(value)\n    return value\n</code></pre>"},{"location":"developer-guide/api/models/utils/#ogc.models.utils.convert_tags_to_slug_tags","title":"convert_tags_to_slug_tags","text":"<pre><code>convert_tags_to_slug_tags(\n    tags: list[str] | None,\n) -&gt; list[str] | None\n</code></pre>  <p>Converts tags to their slugged equivalent</p>  Source code in <code>ogc/models/utils.py</code> <pre><code>def convert_tags_to_slug_tags(tags: list[str] | None) -&gt; list[str] | None:\n    \"\"\"Converts tags to their slugged equivalent\"\"\"\n    if tags:\n        return [slugify(tag) for tag in tags]\n    return None\n</code></pre>"},{"location":"user-guide/defining-layouts/","title":"Defining Layouts","text":"<p>Learn the layout specification and how to create your own provisioning layouts.</p> <p>Create a file <code>ubuntu.py</code>:</p> <pre><code>from ogc.deployer import Deployer\nfrom ogc.log import get_logger\nfrom ogc.models import Layout\nfrom ogc.provision import choose_provisioner\n\nlog = get_logger(\"ogc\")\n\nlayout = Layout(\n    instance_size=\"e2-standard-4\",\n    name=\"ubuntu-ogc\",\n    provider=\"google\",\n    remote_path=\"/home/ubuntu/ogc\",\n    runs_on=\"ubuntu-2004-lts\",\n    scale=5,\n    scripts=\"fixtures/ex_deploy_ubuntu\",\n    username=\"ubuntu\",\n    ssh_private_key=\"~/.ssh/id_rsa_libcloud\",\n    ssh_public_key=\"~/.ssh/id_rsa_libcloud.pub\",\n    ports=[\"22:22\", \"80:80\", \"443:443\", \"5601:5601\"],\n    tags=[],\n    labels=dict(\n        division=\"engineering\", org=\"obs\", team=\"observability\", project=\"perf\"\n    ),\n)\n\n# Alternatively\n# from ogc.provisioner import GCEProvisioner\n# provisioner = GCEProvisioner(layout=layout)\n\nprovisioner = choose_provisioner(layout=layout)\ndeploy = Deployer.from_provisioner(provisioner=provisioner)\ndef up(**kwargs):\n    deploy.up()\n\ndef run(**kwargs):\n    # pass in a directory/filepath -o path=fixtures/ubuntu\n    if kwargs.get(\"path\", None):\n        deploy.exec_scripts(scripts=kwargs[\"path\"])\n    # pass in a cmd with -o cmd='ls -l /'\n    elif kwargs.get(\"cmd\", None):\n        deploy.exec(kwargs[\"cmd\"])\n    else:\n        deploy.exec_scripts()    \n\ndef down(**kwargs):\n    deploy.down()\n</code></pre> <p>Each layout has a friendly name associated as seen by <code>elastic-agent-ubuntu</code>. The next section is going to go over each option and describe its meaning.</p> <p>provider</p> <p>Define which cloud the layout will operate in. Currently supported options are aws and google.</p> <p>runs-on</p> <p>Define the base OS image to be deployed on to the nodes. The current supported list of names are:</p>    AWS Google     ubuntu-2004 ubuntu-2004   ubuntu-1804 ubuntu-1804   ubuntu-1604 ubuntu-1604   sles-15 sles-15   sles-12 sles-12   sles-11 sles-11   debian-10 debian-10   debian-9 debian-9   debian-8 debian-8    rhel-8    rhel-7    rhel-6    <p>instance-size</p> <p>Define the machine size, this is dependent on which provider is chosen. The instance-size correlates with the instance size naming for each cloud. </p> <p>For example, on AWS you would use <code>instance-size = \"c5.4xlarge\"</code> and in Google's case, <code>instance-size = \"e2-standard-4\"</code>.</p> <p>username</p> <p>The ssh user to use when deploying and accessing the nodes. This is also somewhat dependent on which provider is used.</p> <p>In the case of Google, any username can be given. In the case of AWS, the base machines have a pre-loaded user that must be used:</p>    AWS Username     centos centos   debian admin   oracle ec2-user   sles ec2-user   ubuntu ubuntu   windows1 ogc     <p>Caution</p> <p>A lot of cloud machine images disable <code>root</code> login, try to avoid using that as a user and utilize <code>sudo</code> for anything requiring elevated permissions.</p>  <p>scripts</p> <p>The location on your machine where templates/scripts resides. These will be uploaded and executed during the deployment phase.</p>  <p>Note</p> <p>See scripting for more information.</p>  <p>scale</p> <p>How many nodes of each layout to deploy. This is also referenced during a deployment reconciliation phase.</p> <p>remote-path (optional)</p> <p>If set, any uploads/downloads outside of what's defined in <code>scripts</code> will be placed in that remote path.</p> <p>include (optional)</p> <p>A list of files/wildcards to include in the upload</p> <p>exclude (optional)</p> <p>A list of files/wildcards to exclude in the upload</p> <p>artifacts (optional)</p> <p>The remote path where script execution output is stored. This is used when pulling artifacts with <code>ogc pull-artifacts</code> and also utilized during node teardown. This will download any artifacts found into <code>artifacts/instance-name/</code>.</p> <p>tags (optional)</p> <p>Define tags for each layout, allows additional filtering capabilities and deployment options when used with <code>ogc ls</code> and <code>ogc exec</code></p> <p>ports (optional)</p> <p>Define what ingress ports are available when accessing the node.</p>   <ol> <li> <p>This is the default user for our contributed packer build for Windows \u21a9</p> </li> </ol>"},{"location":"user-guide/managing-nodes/","title":"Managing a Deployment","text":"<p>Learn how to list, inspect, access and debug your node deployments.</p>"},{"location":"user-guide/managing-nodes/#listing-nodes","title":"Listing Nodes","text":"<p>To list nodes in your deployment, run the following:</p> <pre><code>$ ogc ls ubuntu.py\n</code></pre> <p>Which gives a table output of current node deployments:</p>"},{"location":"user-guide/managing-nodes/#accessing-nodes","title":"Accessing nodes","text":"<p>OGC provides a helper command for easily accessing any of the nodes in your deployment.</p> <p>To login to a node run:</p> <pre><code>$ ogc ssh ogc-d7cd61a7-elastic-agent-ubuntu\n\n... ssh output ...\n\nogc@ogc-d7cd61a7-elastic-agent-ubuntu:~#\n</code></pre>"},{"location":"user-guide/managing-nodes/#executing-commands","title":"Executing commands","text":"<p>Running arbitrary commands can be accomplished with:</p> <pre><code>$ ogc exec ubuntu.py 'ls -l /'\n</code></pre>"},{"location":"user-guide/managing-nodes/#executing-a-scripts-directory","title":"Executing a scripts directory","text":"<p>In addition to running arbitrary commands, OGC can also execute a directory of templates/scripts:</p> <pre><code>$ ogc exec-scripts ubuntu.py fixtures/ex_deploy_ubuntu\n</code></pre> <p>This can be useful to re-run a deployment or add new functionality/one-offs to a node without disturbing the original layout specifications. Access to the database and all templating is available as well.</p>"},{"location":"user-guide/managing-nodes/#destroying-nodes","title":"Destroying nodes","text":"<p>OGC allows destroying of individual or a full blown cleanup. To remove a single node we run:</p> <pre><code>$ ogc down ubuntu.py --force\n</code></pre>"},{"location":"user-guide/providers/","title":"Providers","text":"<p>In order to access a cloud provider, there are certain environment variables that need to be exposed for each. Each environment variable should be defined in <code>.env</code> file so it will be automatically loaded when running OGC.</p>"},{"location":"user-guide/providers/#aws","title":"AWS","text":"<ul> <li>AWS_ACCESS_KEY_ID</li> <li>AWS_SECRET_ACCESS_KEY</li> <li>AWS_REGION</li> </ul>"},{"location":"user-guide/providers/#google","title":"Google","text":"<ul> <li>GOOGLE_APPLICATION_CREDENTIALS</li> <li>GOOGLE_APPLICATION_SERVICE_ACCOUNT</li> <li>GOOGLE_PROJECT</li> <li>GOOGLE_DATACENTER</li> </ul>"},{"location":"user-guide/scripting/","title":"Scripting","text":"<p>All deployments have the ability to execute scripts once a node becomes available.</p>"},{"location":"user-guide/scripting/#before-starting","title":"Before starting","text":"<p>A couple of things to keep in mind:</p> <ul> <li>All scripts are executed in order based on the filenames. It is recommended to create scripts with a numbered prefix, for example:</li> </ul> <pre><code>- scripts/\n  -  01-install-deps\n  -  02-configure-services\n</code></pre> <ul> <li>There is a special reserved filename <code>teardown</code>, if this file exists it will only be executed during a removal of a node. This is useful for any cleanup actions that may need to be run, such as removing test users, un-enrolling from a service, etc.</li> </ul>"},{"location":"user-guide/scripting/#writing-scripts","title":"Writing scripts","text":"<p>Scripts can be written in any language, it is up to you to configure the nodes so that any runtimes and library dependencies are met on the target node for your script to execute in. </p> <p>One way to accomplish this is to create <code>01-setup-env</code> bash script:</p> <pre><code>#!/bin/bash\n\necho \"Installing python3 on ubuntu\"\nsudo apt-get update\nsudo apt-get install -qyf python3\nsudo pip install sh\n</code></pre> <p>Then in subsequent scripts, using python3 is available. For example, in file <code>02-run-cmd-in-python</code>:</p> <pre><code>#!/usr/bin/env python3\n\nimport sh\n\nsh.ls('/')\nsh.cp('-a', 'mydir', 'anotherdir')\n</code></pre>"},{"location":"user-guide/scripting/#templating","title":"Templating","text":"<p>OGC provides some additional capabilities through templating. Under the hood python-mako is used for the parsing.</p> <p>With templating, you have the ability to query the underlying database to gather node information, a couple of modules are already exposed in the templates context:</p>    Var Description     db Exposes access to the database   node Current deployed node metadata   env Environment variables are made available through this key, <code>env['USER']</code>    <pre><code>#!/bin/bash\n&lt;%! from ogc.templatetags import run, header, hr %&gt;\n\n&lt;%namespace name=\"utils\" file=\"/functions.mako\"/&gt;\n\n${header('Connection information')}\necho \"id: ${node.instance_id}\"\necho \"name: ${node.instance_name}\"\necho \"connection: ${node.layout.username}@${node.public_ip}\"\necho \"provider ${node.layout.provider}\"\n${hr()}\n\n${run('ls', '/', l=True, h=True)}\n\n\n${header('All nodes')}\n% for obj in db.nodes().values():\necho \"id: ${obj.instance_id}\"\necho \"name: ${obj.instance_name}\"\necho \"connection: ${obj.layout.username}@${obj.public_ip}\"\necho \"provider ${obj.layout.provider}\"\n% endfor\n${header('All nodes finished')}\n\n${run('mkdir', node.layout.remote_path + \"/output\", p=True)} &amp;&amp; \\\n${run('touch', node.layout.remote_path + \"/output/test.xml\")}\n</code></pre> <p>The runtime environment is also available within the template context.</p>  <p>Note</p> <p>Any environment variables exported within OGC will be exposed in the templates.</p>"},{"location":"user-guide/scripting/#reusable-helpers","title":"Reusable helpers","text":"<p>In the above example we reference a file called <code>/functions.mako</code> this is just another template file that sits just outside of our defined <code>scripts</code>, for example, if our <code>scripts</code> is defined to be in <code>scripts/my_ubuntu_deploy</code> then this <code>functions.mako</code> will live at <code>scripts/functions.mako</code>. </p>  <p>Alert</p> <p>This is good practice as you may have multiple layouts with different script directories for each and would like to store common functionality in a single place.</p>  <p>Defining helper functions is straight forward, lets look at <code>functions.mako</code> for an example:</p> <pre><code>## Helper template functions downloading/extracting files\n&lt;%def name=\"setup_env()\"&gt;\nif ! test -f \"/usr/local/bin/pacapt\"; then\n    wget -O /usr/local/bin/pacapt https://github.com/icy/pacapt/raw/ng/pacapt\n    chmod 755 /usr/local/bin/pacapt\n    ln -sv /usr/local/bin/pacapt /usr/local/bin/pacman || true\nfi\n&lt;/%def&gt;\n\n&lt;%def name=\"install_pkgs(pkgs)\"&gt;\n% for pkg in pkgs:\npacapt install --noconfirm ${pkg}\n% endfor\n&lt;/%def&gt;\n\n&lt;%def name=\"download(url, src_file)\"&gt;\nwget -O ${src_file} ${url}\n&lt;/%def&gt;\n\n&lt;%def name=\"extract(src, dst=None)\"&gt;\n% if dst:\nmkdir -p ${dst}\ntar -xvf ${src} -C ${dst}\n% else:\ntar -xvf ${src}\n% endif\n&lt;/%def&gt;\n</code></pre> <p>Each <code>%def</code> section defines a function block that when called with any necessary arguments will output that data into the scripts with all necessary translations handled.</p> <p>You can see the usage of these functions in the previous example for installing elastic-agent.</p> <p>It is worth the time to visit Mako's website and learn about its feature set, particularly namespaces and defs and blocks.</p>"},{"location":"user-guide/windows/","title":"Windows","text":"<p>OGC supports provisioning Windows instances, however, it does make a couple of assumptions:</p> <ul> <li>OpenSSH Server is running on the Windows Machine</li> <li>Rsync is installed and available</li> <li>Passwordless ssh is setup</li> </ul> <p>Fortunately, we provide you with a Packer setup that will let you  quickly build an AWS AMI to meet those requirements.</p>  <p>Warning</p> <p>If using OGC contributed packer build, only AWS is supported at this time.</p>"},{"location":"user-guide/windows/#build-ami","title":"Build AMI","text":"<p>The configurations are located in contrib/, to get started run:</p> <pre><code>$ git clone https://github.com/adam-stokes/ogc\n$ cd ogc/contrib\n</code></pre>  <p>Alert</p> <p>If using these Packer configs, please note the default user to use is: <code>ogc</code></p>"},{"location":"user-guide/windows/#windows-2019","title":"Windows 2019","text":"<p>To build a Windows 2019 Server instance run:</p> <pre><code>ogc/contrib&gt; $ packer build windows2019.json\n</code></pre> <p>Once complete, grab the AMI ID, as this will be used in the <code>layout</code> specification of OGC.</p>"},{"location":"user-guide/windows/#usage","title":"Usage","text":"<p>To provision and deploy a Windows machine, the following example spec will work:</p> <p>Create a file <code>windows.py</code>:</p> <pre><code>from ogc.deployer import Deployer\nfrom ogc.log import get_logger\nfrom ogc.models import Layout\nfrom ogc.provision import choose_provisioner\n\nlog = get_logger(\"ogc\")\n\nlayout = Layout(\n    instance_size=\"c5.2xlarge\",\n    name=\"ubuntu-ogc\",\n    provider=\"aws\",\n    remote_path=\"ogc-src\",\n    runs_on=\"ami-0587bd602f1da2f1d\",\n    scale=1,\n    scripts=\"fixtures/ex_deploy_windows\",\n    username=\"ogc\",\n    ssh_private_key=\"~/.ssh/id_rsa_libcloud\",\n    ssh_public_key=\"~/.ssh/id_rsa_libcloud.pub\",\n    ports=[\"22:22\", \"80:80\", \"443:443\", \"5601:5601\"],\n    tags=[],\n    labels=dict(\n        division=\"engineering\", org=\"obs\", team=\"observability\", project=\"perf\"\n    ),\n)\n\n# Alternatively\n# from ogc.provisioner import GCEProvisioner\n# provisioner = GCEProvisioner(layout=layout)\n\nprovisioner = choose_provisioner(layout=layout)\ndeploy = Deployer.from_provisioner(provisioner=provisioner)\ndef up(**kwargs):\n    deploy.up()\n\ndef run(**kwargs):\n    # pass in a directory/filepath -o path=fixtures/ubuntu\n    if kwargs.get(\"path\", None):\n        deploy.exec_scripts(scripts=kwargs[\"path\"])\n    # pass in a cmd with -o cmd='ls -l /'\n    elif kwargs.get(\"cmd\", None):\n        deploy.exec(kwargs[\"cmd\"])\n    else:\n        deploy.exec_scripts()    \n\ndef down(**kwargs):\n    deploy.down()\n</code></pre> <p>Once defined, simply running:</p> <pre><code>$ ogc up windows.py\n</code></pre> <p>Will get you a provisioned Windows machine!</p>"},{"location":"user-guide/windows/#scripting","title":"Scripting","text":"<p>Powershell a good choice, works out of the box on Windows, however, if you want to use a different programming  language the choice is yours. All the templating, database, and context is available.</p> <p>For example, to print out the current node information, edit a file <code>01-powershell</code>:</p> <pre><code>powershell echo \"${node.instance_name}:${node.public_ip}\" &gt; ${node.instance_name}.txt\n</code></pre> <p>This is a simple example, for a more advanced deployment it may be best to create  your <code>ps1</code> files and then reference them through powershell interpreter.</p>"},{"location":"user-guide/cookbook/template-access-node-info/","title":"Accessing node information","text":""},{"location":"user-guide/cookbook/template-access-node-info/#current-node","title":"Current node","text":"<p>In template files you have access to the node that is currently being rendered prior to those scripts being uploaded.</p> <p>Below is an example of querying the current node's information and outputting it to a file:</p> <pre><code>#!/bin/bash\n\necho \"### CURRENT NODE\" &gt;&gt; node_info.txt\necho \"[ID: ${node.id}] Name: ${node.instance_name} || Connection: ${node.username}@${node.public_ip} || Provider: ${node.provider}\" &gt;&gt; node_info.txt\necho \"### CURRENT NODE\" &gt;&gt; node_info.txt\n</code></pre> <p>Save this file in the location of your defined <code>scripts</code> and give it a indexed name of where in the order it should be executed, for example, <code>01-show-node-info</code>1.</p>"},{"location":"user-guide/cookbook/template-access-node-info/#all-nodes","title":"All nodes","text":"<p>In some cases you may need to grab information from another node in the deployment, for example, a second node running Kibana in which the first node needs to perform some kind of API calls against it. </p> <p>We can accomplish this using the <code>db</code> and modules that's exposed in our templates. Create a file <code>02-curl-remote</code> with the following:</p> <pre><code>#!/bin/bash\nsudo pip install httpie\nKIBANA_HOST=${node.instance_name.contains([\"kibana\"]).first() or '')}\n\nhttp -a username:passsword -f GET https://$KIBANA_HOST:5601/fleet/setup kbn-xsrf:ogc\n</code></pre>   <ol> <li> <p>See the Scripting documentation for ordering of files.\u00a0\u21a9</p> </li> </ol>"}]}